{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Torch Find Peaks Documentation","text":"<p>Welcome to the documentation for the <code>torch-find-peaks</code> library.</p>"},{"location":"#overview","title":"Overview","text":"<p>The <code>torch-find-peaks</code> library provides utilities for detecting and refining peaks in 2D and 3D data using PyTorch. It includes methods for peak detection, Gaussian fitting, and more.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the library, use:</p> <pre><code>pip install torch-find-peaks\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Here are some of the key functionalities provided by the library:</p> <ul> <li>Peak Detection: Detect peaks in 2D images or 3D volumes.</li> <li>Gaussian Fitting: Fit 2D or 3D Gaussian functions to refine peak positions.</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#torch_find_peaksfind_peaks","title":"<code>torch_find_peaks.find_peaks</code>","text":""},{"location":"#torch_find_peaks.find_peaks.find_peaks_2d","title":"<code>find_peaks_2d(image, min_distance=1, threshold_abs=0.0, exclude_border=0, return_as='torch')</code>","text":"<p>Find local peaks in a 2D image.</p> <p>Accepts various input types (torch.Tensor, numpy.ndarray) and attempts to convert them to torch.Tensor before processing.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Any</code> <p>A 2D tensor-like object (e.g., torch.Tensor, numpy.ndarray) representing the input image.</p> required <code>min_distance</code> <code>int</code> <p>Minimum distance between peaks. Default is 1.</p> <code>1</code> <code>threshold_abs</code> <code>float</code> <p>Minimum intensity value for a peak to be considered. Default is 0.0.</p> <code>0.0</code> <code>exclude_border</code> <code>int</code> <p>Width of the border to exclude from peak detection. Default is 0.</p> <code>0</code> <code>return_as</code> <code>str</code> <p>The format of the output. Default is \"torch\". Other options are \"numpy\" and \"dataframe\".</p> <code>'torch'</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (N, 2), where N is the number of peaks, and each row contains the (Y, X) coordinates of a peak.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input image cannot be converted to a torch.Tensor.</p> <code>ValueError</code> <p>If the input image is not 2-dimensional after conversion.</p> Source code in <code>src/torch_find_peaks/find_peaks.py</code> <pre><code>def find_peaks_2d(\n        image: Union[torch.Tensor, np.ndarray], \n        min_distance: int = 1,\n        threshold_abs: float = 0.0,\n        exclude_border: int = 0,\n        return_as: str = \"torch\",\n) -&gt; torch.Tensor:\n    \"\"\"\n    Find local peaks in a 2D image.\n\n    Accepts various input types (torch.Tensor, numpy.ndarray) and attempts\n    to convert them to torch.Tensor before processing.\n\n    Parameters\n    ----------\n    image : Any\n        A 2D tensor-like object (e.g., torch.Tensor, numpy.ndarray)\n        representing the input image.\n    min_distance : int, optional\n        Minimum distance between peaks. Default is 1.\n    threshold_abs : float, optional\n        Minimum intensity value for a peak to be considered. Default is 0.0.\n    exclude_border : int, optional\n        Width of the border to exclude from peak detection. Default is 0.\n    return_as : str, optional\n        The format of the output. Default is \"torch\".\n        Other options are \"numpy\" and \"dataframe\".\n\n    Returns\n    -------\n    torch.Tensor\n        A tensor of shape (N, 2), where N is the number of peaks, and each row\n        contains the (Y, X) coordinates of a peak.\n\n    Raises\n    ------\n    TypeError\n        If the input image cannot be converted to a torch.Tensor.\n    ValueError\n        If the input image is not 2-dimensional after conversion.\n    \"\"\"\n    if isinstance(image, torch.Tensor):\n        image_tensor = image\n    elif isinstance(image, np.ndarray):\n        image_tensor = torch.from_numpy(image)\n    # Add checks for pandas/polars DataFrames/Series here if needed\n    # elif pd and isinstance(image, pd.DataFrame):\n    #     image_tensor = torch.from_numpy(image.values)\n    # elif pl and isinstance(image, pl.DataFrame):\n    #     image_tensor = torch.from_numpy(image.to_numpy())\n    else:\n        try:\n            # Attempt a general conversion for other array-like objects\n            image_tensor = torch.as_tensor(image)\n        except Exception as e:\n            raise TypeError(\n                f\"Input type {type(image)} not supported or conversion failed: {e}\"\n            )\n\n    if image_tensor.ndim != 2:\n        raise ValueError(\n            f\"Input image must be 2-dimensional, but got {image_tensor.ndim} dimensions.\"\n        )\n\n    found_peaks, heights = _find_peaks_2d_torch(\n        image=image_tensor,\n        min_distance=min_distance,\n        threshold_abs=threshold_abs,\n        exclude_border=exclude_border,\n    )\n\n    if return_as == \"torch\":\n        return found_peaks, heights\n    elif return_as == \"numpy\":\n        return found_peaks.numpy(), heights.numpy()\n    elif return_as == \"dataframe\":\n        return pl.DataFrame(torch.cat([found_peaks, heights], dim=1), columns=[\"y\", \"x\", \"height\"])\n    else:\n        raise ValueError(f\"Invalid return_as value: {return_as}\")\n</code></pre>"},{"location":"#torch_find_peaks.find_peaks.find_peaks_3d","title":"<code>find_peaks_3d(volume, min_distance=1, threshold_abs=0.0, exclude_border=0, return_as='torch')</code>","text":"<p>Find local peaks in a 3D volume.</p> <p>Accepts various input types (torch.Tensor, numpy.ndarray) and attempts to convert them to torch.Tensor before processing.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>Any</code> <p>A 3D tensor-like object (e.g., torch.Tensor, numpy.ndarray) representing the input volume.</p> required <code>min_distance</code> <code>int</code> <p>Minimum distance between peaks. Default is 1.</p> <code>1</code> <code>threshold_abs</code> <code>float</code> <p>Minimum intensity value for a peak to be considered. Default is 0.0.</p> <code>0.0</code> <code>exclude_border</code> <code>int</code> <p>Width of the border to exclude from peak detection. Default is 0.</p> <code>0</code> <code>return_as</code> <code>str</code> <p>The format of the output. Default is \"torch\". Other options are \"numpy\" and \"dataframe\".</p> <code>'torch'</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (N, 3), where N is the number of peaks, and each row contains the (Z, Y, X) coordinates of a peak.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input volume cannot be converted to a torch.Tensor.</p> <code>ValueError</code> <p>If the input volume is not 3-dimensional after conversion.</p> Source code in <code>src/torch_find_peaks/find_peaks.py</code> <pre><code>def find_peaks_3d(\n        volume: Union[torch.Tensor, np.ndarray], \n        min_distance: int = 1,\n        threshold_abs: float = 0.0,\n        exclude_border: int = 0,\n        return_as: str = \"torch\",\n) -&gt; torch.Tensor:\n    \"\"\"\n    Find local peaks in a 3D volume.\n\n    Accepts various input types (torch.Tensor, numpy.ndarray) and attempts\n    to convert them to torch.Tensor before processing.\n\n    Parameters\n    ----------\n    volume : Any\n        A 3D tensor-like object (e.g., torch.Tensor, numpy.ndarray)\n        representing the input volume.\n    min_distance : int, optional\n        Minimum distance between peaks. Default is 1.\n    threshold_abs : float, optional\n        Minimum intensity value for a peak to be considered. Default is 0.0.\n    exclude_border : int, optional\n        Width of the border to exclude from peak detection. Default is 0.\n    return_as : str, optional\n        The format of the output. Default is \"torch\".\n        Other options are \"numpy\" and \"dataframe\".\n\n    Returns\n    -------\n    torch.Tensor\n        A tensor of shape (N, 3), where N is the number of peaks, and each row\n        contains the (Z, Y, X) coordinates of a peak.\n\n    Raises\n    ------\n    TypeError\n        If the input volume cannot be converted to a torch.Tensor.\n    ValueError\n        If the input volume is not 3-dimensional after conversion.\n    \"\"\"\n    if isinstance(volume, torch.Tensor):\n        volume_tensor = volume\n    elif isinstance(volume, np.ndarray):\n        volume_tensor = torch.from_numpy(volume)\n    # Add checks for pandas/polars DataFrames/Series here if needed\n    else:\n        try:\n            # Attempt a general conversion for other array-like objects\n            volume_tensor = torch.as_tensor(volume)\n        except Exception as e:\n            raise TypeError(\n                f\"Input type {type(volume)} not supported or conversion failed: {e}\"\n            )\n\n    if volume_tensor.ndim != 3:\n        raise ValueError(\n            f\"Input volume must be 3-dimensional, but got {volume_tensor.ndim} dimensions.\"\n        )\n\n    found_peaks, heights = _find_peaks_3d_torch(\n        volume=volume_tensor,\n        min_distance=min_distance,\n        threshold_abs=threshold_abs,\n        exclude_border=exclude_border,\n    )\n\n    if return_as == \"torch\":\n        return found_peaks, heights\n    elif return_as == \"numpy\":\n        return found_peaks.numpy(), heights.numpy()\n    elif return_as == \"dataframe\":\n        return pl.DataFrame(torch.cat([found_peaks, heights], dim=1), columns=[\"z\", \"y\", \"x\", \"height\"])\n    else:\n        raise ValueError(f\"Invalid return_as value: {return_as}\")\n</code></pre>"},{"location":"#torch_find_peaksrefine_peaks","title":"<code>torch_find_peaks.refine_peaks</code>","text":""},{"location":"#torch_find_peaks.refine_peaks.refine_peaks_2d","title":"<code>refine_peaks_2d(image, peak_coords, boxsize, max_iterations=1000, learning_rate=0.01, tolerance=1e-06, amplitude=1.0, sigma_x=1.0, sigma_y=1.0)</code>","text":"<p>Refine the positions of peaks in a 2D image by fitting 2D Gaussian functions.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Any</code> <p>A 2D tensor-like object (e.g., torch.Tensor, numpy.ndarray) containing the image data.</p> required <code>peak_coords</code> <code>Any</code> <p>A tensor-like object of shape (n, 2) containing the initial peak coordinates (y, x).</p> required <code>boxsize</code> <code>int</code> <p>Size of the region to crop around each peak (must be even).</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of optimization iterations. Default is 1000.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for the optimizer. Default is 0.01.</p> <code>0.01</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance for the optimization. Default is 1e-6.</p> <code>1e-06</code> <code>amplitude</code> <code>Union[Tensor, float]</code> <p>Initial amplitude of the Gaussian. Default is 1.0.</p> <code>1.0</code> <code>sigma_x</code> <code>Union[Tensor, float]</code> <p>Initial standard deviation in the x direction. Default is 1.0.</p> <code>1.0</code> <code>sigma_y</code> <code>Union[Tensor, float]</code> <p>Initial standard deviation in the y direction. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (n, 5) containing the fitted parameters for each peak. Each row contains [amplitude, center_x, center_y, sigma_x, sigma_y].</p> Source code in <code>src/torch_find_peaks/refine_peaks.py</code> <pre><code>def refine_peaks_2d(\n    image: Any,\n    peak_coords: Any,\n    boxsize: int,\n    max_iterations: int = 1000,\n    learning_rate: float = 0.01,\n    tolerance: float = 1e-6,\n    amplitude: Union[torch.Tensor, float] = 1.,\n    sigma_x: Union[torch.Tensor, float] = 1.,\n    sigma_y: Union[torch.Tensor, float] = 1.,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Refine the positions of peaks in a 2D image by fitting 2D Gaussian functions.\n\n    Parameters\n    ----------\n    image : Any\n        A 2D tensor-like object (e.g., torch.Tensor, numpy.ndarray)\n        containing the image data.\n    peak_coords : Any\n        A tensor-like object of shape (n, 2) containing the initial peak coordinates (y, x).\n    boxsize : int\n        Size of the region to crop around each peak (must be even).\n    max_iterations : int, optional\n        Maximum number of optimization iterations. Default is 1000.\n    learning_rate : float, optional\n        Learning rate for the optimizer. Default is 0.01.\n    tolerance : float, optional\n        Convergence tolerance for the optimization. Default is 1e-6.\n    amplitude : Union[torch.Tensor, float], optional\n        Initial amplitude of the Gaussian. Default is 1.0.\n    sigma_x : Union[torch.Tensor, float], optional\n        Initial standard deviation in the x direction. Default is 1.0.\n    sigma_y : Union[torch.Tensor, float], optional\n        Initial standard deviation in the y direction. Default is 1.0.\n\n    Returns\n    -------\n    torch.Tensor\n        A tensor of shape (n, 5) containing the fitted parameters for each peak.\n        Each row contains [amplitude, center_x, center_y, sigma_x, sigma_y].\n    \"\"\"\n    if not isinstance(image, torch.Tensor):\n        image = torch.as_tensor(image)\n    if not isinstance(peak_coords, torch.Tensor):\n        peak_coords = torch.as_tensor(peak_coords)\n\n    num_peaks = peak_coords.shape[0]\n    if not isinstance(amplitude, torch.Tensor):\n        amplitude = torch.tensor([amplitude] * num_peaks, device=image.device)\n    if not isinstance(sigma_x, torch.Tensor):\n        sigma_x = torch.tensor([sigma_x] * num_peaks, device=image.device)\n    if not isinstance(sigma_y, torch.Tensor):\n        sigma_y = torch.tensor([sigma_y] * num_peaks, device=image.device)\n\n    return _refine_peaks_2d_torch(\n        image=image,\n        peak_coords=peak_coords,\n        boxsize=boxsize,\n        max_iterations=max_iterations,\n        learning_rate=learning_rate,\n        tolerance=tolerance,\n        amplitude=amplitude,\n        sigma_x=sigma_x,\n        sigma_y=sigma_y,\n    )\n</code></pre>"},{"location":"#torch_find_peaks.refine_peaks.refine_peaks_3d","title":"<code>refine_peaks_3d(volume, peak_coords, boxsize, max_iterations=1000, learning_rate=0.01, tolerance=1e-06, amplitude=1.0, sigma_x=1.0, sigma_y=1.0, sigma_z=1.0)</code>","text":"<p>Refine the positions of peaks in a 3D volume by fitting 3D Gaussian functions.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>Any</code> <p>A 3D tensor-like object (e.g., torch.Tensor, numpy.ndarray) containing the volume data.</p> required <code>peak_coords</code> <code>Any</code> <p>A tensor-like object of shape (n, 3) containing the initial peak coordinates (z, y, x).</p> required <code>boxsize</code> <code>int</code> <p>Size of the region to crop around each peak (must be even).</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of optimization iterations. Default is 1000.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for the optimizer. Default is 0.01.</p> <code>0.01</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance for the optimization. Default is 1e-6.</p> <code>1e-06</code> <code>amplitude</code> <code>Union[Tensor, float]</code> <p>Initial amplitude of the Gaussian. Default is 1.0.</p> <code>1.0</code> <code>sigma_x</code> <code>Union[Tensor, float]</code> <p>Initial standard deviation in the x direction. Default is 1.0.</p> <code>1.0</code> <code>sigma_y</code> <code>Union[Tensor, float]</code> <p>Initial standard deviation in the y direction. Default is 1.0.</p> <code>1.0</code> <code>sigma_z</code> <code>Union[Tensor, float]</code> <p>Initial standard deviation in the z direction. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (n, 7) containing the fitted parameters for each peak. Each row contains [amplitude, center_x, center_y, center_z, sigma_x, sigma_y, sigma_z].</p> Source code in <code>src/torch_find_peaks/refine_peaks.py</code> <pre><code>def refine_peaks_3d(\n    volume: Any,\n    peak_coords: Any,\n    boxsize: int,\n    max_iterations: int = 1000,\n    learning_rate: float = 0.01,\n    tolerance: float = 1e-6,\n    amplitude: Union[torch.Tensor, float] = 1.,\n    sigma_x: Union[torch.Tensor, float] = 1.,\n    sigma_y: Union[torch.Tensor, float] = 1.,\n    sigma_z: Union[torch.Tensor, float] = 1.,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Refine the positions of peaks in a 3D volume by fitting 3D Gaussian functions.\n\n    Parameters\n    ----------\n    volume : Any\n        A 3D tensor-like object (e.g., torch.Tensor, numpy.ndarray)\n        containing the volume data.\n    peak_coords : Any\n        A tensor-like object of shape (n, 3) containing the initial peak coordinates (z, y, x).\n    boxsize : int\n        Size of the region to crop around each peak (must be even).\n    max_iterations : int, optional\n        Maximum number of optimization iterations. Default is 1000.\n    learning_rate : float, optional\n        Learning rate for the optimizer. Default is 0.01.\n    tolerance : float, optional\n        Convergence tolerance for the optimization. Default is 1e-6.\n    amplitude : Union[torch.Tensor, float], optional\n        Initial amplitude of the Gaussian. Default is 1.0.\n    sigma_x : Union[torch.Tensor, float], optional\n        Initial standard deviation in the x direction. Default is 1.0.\n    sigma_y : Union[torch.Tensor, float], optional\n        Initial standard deviation in the y direction. Default is 1.0.\n    sigma_z : Union[torch.Tensor, float], optional\n        Initial standard deviation in the z direction. Default is 1.0.\n\n    Returns\n    -------\n    torch.Tensor\n        A tensor of shape (n, 7) containing the fitted parameters for each peak.\n        Each row contains [amplitude, center_x, center_y, center_z, sigma_x, sigma_y, sigma_z].\n    \"\"\"\n    if not isinstance(volume, torch.Tensor):\n        volume = torch.as_tensor(volume)\n    if not isinstance(peak_coords, torch.Tensor):\n        peak_coords = torch.as_tensor(peak_coords)\n\n    num_peaks = peak_coords.shape[0]\n    if not isinstance(amplitude, torch.Tensor):\n        amplitude = torch.tensor([amplitude] * num_peaks, device=volume.device)\n    if not isinstance(sigma_x, torch.Tensor):\n        sigma_x = torch.tensor([sigma_x] * num_peaks, device=volume.device)\n    if not isinstance(sigma_y, torch.Tensor):\n        sigma_y = torch.tensor([sigma_y] * num_peaks, device=volume.device)\n    if not isinstance(sigma_z, torch.Tensor):\n        sigma_z = torch.tensor([sigma_z] * num_peaks, device=volume.device)\n\n    return _refine_peaks_3d_torch(\n        volume=volume,\n        peak_coords=peak_coords,\n        boxsize=boxsize,\n        max_iterations=max_iterations,\n        learning_rate=learning_rate,\n        tolerance=tolerance,\n        amplitude=amplitude,\n        sigma_x=sigma_x,\n        sigma_y=sigma_y,\n        sigma_z=sigma_z,\n    )\n</code></pre>"},{"location":"#torch_find_peaksgaussians","title":"<code>torch_find_peaks.gaussians</code>","text":""},{"location":"#torch_find_peaks.gaussians.Gaussian2D","title":"<code>Gaussian2D</code>","text":"<p>               Bases: <code>Module</code></p> <p>A 2D Gaussian function.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>tensor</code> <p>Amplitude of the Gaussian. Default is torch.tensor([1.0]).</p> <code>1.0</code> <code>center_x</code> <code>tensor</code> <p>X-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>0.0</code> <code>center_y</code> <code>tensor</code> <p>Y-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>0.0</code> <code>sigma_x</code> <code>tensor</code> <p>Standard deviation along the x-axis. Default is torch.tensor([1.0]).</p> <code>1.0</code> <code>sigma_y</code> <code>tensor</code> <p>Standard deviation along the y-axis. Default is torch.tensor([1.0]).</p> <code>1.0</code> <p>Methods:</p> Name Description <code>forward</code> <p>Compute the Gaussian values for a given 2D grid.</p> Source code in <code>src/torch_find_peaks/gaussians.py</code> <pre><code>class Gaussian2D(nn.Module):\n    \"\"\"\n    A 2D Gaussian function.\n\n    Parameters\n    ----------\n    amplitude : torch.tensor, optional\n        Amplitude of the Gaussian. Default is torch.tensor([1.0]).\n    center_x : torch.tensor, optional\n        X-coordinate of the center. Default is torch.tensor([0.0]).\n    center_y : torch.tensor, optional\n        Y-coordinate of the center. Default is torch.tensor([0.0]).\n    sigma_x : torch.tensor, optional\n        Standard deviation along the x-axis. Default is torch.tensor([1.0]).\n    sigma_y : torch.tensor, optional\n        Standard deviation along the y-axis. Default is torch.tensor([1.0]).\n\n    Methods\n    -------\n    forward(grid)\n        Compute the Gaussian values for a given 2D grid.\n    \"\"\"\n\n    def __init__(self,\n                 amplitude: Union[torch.Tensor | float] = 1.0,\n                 center_x: Union[torch.Tensor | float] = 0.0,\n                 center_y: Union[torch.Tensor | float] = 0.0,\n                 sigma_x: Union[torch.Tensor | float] = 1.0,\n                 sigma_y: Union[torch.Tensor | float] = 1.0\n    ):\n        super(Gaussian2D, self).__init__()\n        # Ensure that the parameters are tensors\n        if not isinstance(amplitude, torch.Tensor):\n            amplitude = torch.tensor(amplitude)\n        if not isinstance(center_x, torch.Tensor):\n            center_x = torch.tensor(center_x)\n        if not isinstance(center_y, torch.Tensor):\n            center_y = torch.tensor(center_y)\n        if not isinstance(sigma_x, torch.Tensor):\n            sigma_x = torch.tensor(sigma_x)\n        if not isinstance(sigma_y, torch.Tensor):\n            sigma_y = torch.tensor(sigma_y)\n        # Check if all parameters are of the same shape\n        assert amplitude.shape == center_x.shape == center_y.shape == sigma_x.shape == sigma_y.shape, \\\n            \"All parameters must have the same shape.\"\n\n        self.amplitude = nn.Parameter(amplitude)\n        self.center_x = nn.Parameter(center_x)\n        self.center_y = nn.Parameter(center_y)\n        self.sigma_x = nn.Parameter(sigma_x)\n        self.sigma_y = nn.Parameter(sigma_y)\n\n    def forward(self, grid):\n        \"\"\"\n        Forward pass for 2D Gaussian list.\n\n        Args:\n            grid: Tensor of shape (h,w, 2) containing 2D coordinates.\n\n        Returns\n        -------\n            Tensor of Gaussian values\n        \"\"\"\n        # Add batch dimension\n        grid_x = einops.rearrange(grid[..., 1], 'h w -&gt; h w' + ' 1'*self.amplitude.dim())\n        grid_y = einops.rearrange(grid[..., 0], 'h w -&gt; h w' + ' 1'*self.amplitude.dim())\n\n        amplitude = einops.rearrange(self.amplitude, '... -&gt; 1 1 ...')\n        center_x = einops.rearrange(self.center_x, '... -&gt; 1 1 ...')\n        center_y = einops.rearrange(self.center_y, '... -&gt; 1 1 ...')\n        sigma_x = einops.rearrange(self.sigma_x, '... -&gt; 1 1 ...')\n        sigma_y = einops.rearrange(self.sigma_y, '... -&gt; 1 1 ...')\n\n        gaussian = amplitude * torch.exp(\n            -((grid_x - center_x) ** 2 / (2 * sigma_x ** 2) +\n              (grid_y - center_y) ** 2 / (2 * sigma_y ** 2))\n        )\n\n        return einops.rearrange(gaussian, 'h w ... -&gt; ... h w')\n</code></pre>"},{"location":"#torch_find_peaks.gaussians.Gaussian2D.forward","title":"<code>forward(grid)</code>","text":"<p>Forward pass for 2D Gaussian list.</p> <p>Args:     grid: Tensor of shape (h,w, 2) containing 2D coordinates.</p> <p>Returns:</p> Type Description <code>    Tensor of Gaussian values</code> Source code in <code>src/torch_find_peaks/gaussians.py</code> <pre><code>def forward(self, grid):\n    \"\"\"\n    Forward pass for 2D Gaussian list.\n\n    Args:\n        grid: Tensor of shape (h,w, 2) containing 2D coordinates.\n\n    Returns\n    -------\n        Tensor of Gaussian values\n    \"\"\"\n    # Add batch dimension\n    grid_x = einops.rearrange(grid[..., 1], 'h w -&gt; h w' + ' 1'*self.amplitude.dim())\n    grid_y = einops.rearrange(grid[..., 0], 'h w -&gt; h w' + ' 1'*self.amplitude.dim())\n\n    amplitude = einops.rearrange(self.amplitude, '... -&gt; 1 1 ...')\n    center_x = einops.rearrange(self.center_x, '... -&gt; 1 1 ...')\n    center_y = einops.rearrange(self.center_y, '... -&gt; 1 1 ...')\n    sigma_x = einops.rearrange(self.sigma_x, '... -&gt; 1 1 ...')\n    sigma_y = einops.rearrange(self.sigma_y, '... -&gt; 1 1 ...')\n\n    gaussian = amplitude * torch.exp(\n        -((grid_x - center_x) ** 2 / (2 * sigma_x ** 2) +\n          (grid_y - center_y) ** 2 / (2 * sigma_y ** 2))\n    )\n\n    return einops.rearrange(gaussian, 'h w ... -&gt; ... h w')\n</code></pre>"},{"location":"#torch_find_peaks.gaussians.Gaussian3D","title":"<code>Gaussian3D</code>","text":"<p>               Bases: <code>Module</code></p> <p>A 3D Gaussian function.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>tensor</code> <p>Amplitude of the Gaussian. Default is torch.tensor([1.0]).</p> <code>tensor(1.0)</code> <code>center_x</code> <code>tensor</code> <p>X-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>tensor(0.0)</code> <code>center_y</code> <code>tensor</code> <p>Y-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>tensor(0.0)</code> <code>center_z</code> <code>tensor</code> <p>Z-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>tensor(0.0)</code> <code>sigma_x</code> <code>tensor</code> <p>Standard deviation along the x-axis. Default is torch.tensor([1.0]).</p> <code>tensor(1.0)</code> <code>sigma_y</code> <code>tensor</code> <p>Standard deviation along the y-axis. Default is torch.tensor([1.0]).</p> <code>tensor(1.0)</code> <code>sigma_z</code> <code>tensor</code> <p>Standard deviation along the z-axis. Default is torch.tensor([1.0]).</p> <code>tensor(1.0)</code> <p>Methods:</p> Name Description <code>forward</code> <p>Compute the Gaussian values for a given 3D grid.</p> Source code in <code>src/torch_find_peaks/gaussians.py</code> <pre><code>class Gaussian3D(nn.Module):\n    \"\"\"\n    A 3D Gaussian function.\n\n    Parameters\n    ----------\n    amplitude : torch.tensor, optional\n        Amplitude of the Gaussian. Default is torch.tensor([1.0]).\n    center_x : torch.tensor, optional\n        X-coordinate of the center. Default is torch.tensor([0.0]).\n    center_y : torch.tensor, optional\n        Y-coordinate of the center. Default is torch.tensor([0.0]).\n    center_z : torch.tensor, optional\n        Z-coordinate of the center. Default is torch.tensor([0.0]).\n    sigma_x : torch.tensor, optional\n        Standard deviation along the x-axis. Default is torch.tensor([1.0]).\n    sigma_y : torch.tensor, optional\n        Standard deviation along the y-axis. Default is torch.tensor([1.0]).\n    sigma_z : torch.tensor, optional\n        Standard deviation along the z-axis. Default is torch.tensor([1.0]).\n\n    Methods\n    -------\n    forward(grid)\n        Compute the Gaussian values for a given 3D grid.\n    \"\"\"\n\n    def __init__(self,\n                 amplitude: torch.tensor = torch.tensor(1.0),\n                 center_x: torch.tensor = torch.tensor(0.0),\n                 center_y: torch.tensor = torch.tensor(0.0),\n                 center_z: torch.tensor = torch.tensor(0.0),\n                 sigma_x: torch.tensor = torch.tensor(1.0),\n                 sigma_y: torch.tensor = torch.tensor(1.0),\n                 sigma_z: torch.tensor = torch.tensor(1.0)\n    ):\n        super(Gaussian3D, self).__init__()\n        # Ensure that the parameters are tensors\n        if not isinstance(amplitude, torch.Tensor):\n            amplitude = torch.tensor(amplitude)\n        if not isinstance(center_x, torch.Tensor):\n            center_x = torch.tensor(center_x)\n        if not isinstance(center_y, torch.Tensor):\n            center_y = torch.tensor(center_y)\n        if not isinstance(center_z, torch.Tensor):\n            center_z = torch.tensor(center_z)\n        if not isinstance(sigma_x, torch.Tensor):\n            sigma_x = torch.tensor(sigma_x)\n        if not isinstance(sigma_y, torch.Tensor):\n            sigma_y = torch.tensor(sigma_y)\n        if not isinstance(sigma_z, torch.Tensor):\n            sigma_z = torch.tensor(sigma_z)\n        # Check if all parameters are of the same shape\n        assert amplitude.shape == center_x.shape == center_y.shape == center_z.shape == sigma_x.shape == sigma_y.shape == sigma_z.shape, \\\n            \"All parameters must have the same shape.\"\n\n        self.amplitude = nn.Parameter(amplitude)\n        self.center_x = nn.Parameter(center_x)\n        self.center_y = nn.Parameter(center_y)\n        self.center_z = nn.Parameter(center_z)\n        self.sigma_x = nn.Parameter(sigma_x)\n        self.sigma_y = nn.Parameter(sigma_y)\n        self.sigma_z = nn.Parameter(sigma_z)\n\n    def forward(self, grid):\n        \"\"\"\n        Forward pass for 3D Gaussian list.\n\n        Args:\n            grid: Tensor of shape (d, h, w, 3) containing 3D coordinates.\n\n        Returns\n        -------\n            Tensor of Gaussian values\n        \"\"\"\n         # Add batch dimension\n        grid_x = einops.rearrange(grid[..., 2], 'd h w -&gt; d h w' + ' 1'*self.amplitude.dim())\n        grid_y = einops.rearrange(grid[..., 1], 'd h w -&gt; d h w' + ' 1'*self.amplitude.dim())\n        grid_z = einops.rearrange(grid[..., 0], 'd h w -&gt; d h w' + ' 1'*self.amplitude.dim())\n\n        amplitude = einops.rearrange(self.amplitude, '... -&gt; 1 1 1 ...')\n        center_x = einops.rearrange(self.center_x, '... -&gt; 1 1 1 ...')\n        center_y = einops.rearrange(self.center_y, '... -&gt; 1 1 1 ...')\n        center_z = einops.rearrange(self.center_z, '... -&gt; 1 1 1 ...')\n        sigma_x = einops.rearrange(self.sigma_x, '... -&gt; 1 1 1 ...')\n        sigma_y = einops.rearrange(self.sigma_y, '... -&gt; 1 1 1 ...')\n        sigma_z = einops.rearrange(self.sigma_z, '... -&gt; 1 1 1 ...')\n\n\n        gaussian = amplitude * torch.exp(\n            -((grid_x - center_x) ** 2 / (2 * sigma_x ** 2) +\n              (grid_y - center_y) ** 2 / (2 * sigma_y ** 2) +\n              (grid_z - center_z) ** 2 / (2 * sigma_z ** 2))\n        )\n\n        return einops.rearrange(gaussian, 'd h w ... -&gt; ... d h w')\n</code></pre>"},{"location":"#torch_find_peaks.gaussians.Gaussian3D.forward","title":"<code>forward(grid)</code>","text":"<p>Forward pass for 3D Gaussian list.</p> <p>Args:     grid: Tensor of shape (d, h, w, 3) containing 3D coordinates.</p> <p>Returns:</p> Type Description <code>    Tensor of Gaussian values</code> Source code in <code>src/torch_find_peaks/gaussians.py</code> <pre><code>def forward(self, grid):\n    \"\"\"\n    Forward pass for 3D Gaussian list.\n\n    Args:\n        grid: Tensor of shape (d, h, w, 3) containing 3D coordinates.\n\n    Returns\n    -------\n        Tensor of Gaussian values\n    \"\"\"\n     # Add batch dimension\n    grid_x = einops.rearrange(grid[..., 2], 'd h w -&gt; d h w' + ' 1'*self.amplitude.dim())\n    grid_y = einops.rearrange(grid[..., 1], 'd h w -&gt; d h w' + ' 1'*self.amplitude.dim())\n    grid_z = einops.rearrange(grid[..., 0], 'd h w -&gt; d h w' + ' 1'*self.amplitude.dim())\n\n    amplitude = einops.rearrange(self.amplitude, '... -&gt; 1 1 1 ...')\n    center_x = einops.rearrange(self.center_x, '... -&gt; 1 1 1 ...')\n    center_y = einops.rearrange(self.center_y, '... -&gt; 1 1 1 ...')\n    center_z = einops.rearrange(self.center_z, '... -&gt; 1 1 1 ...')\n    sigma_x = einops.rearrange(self.sigma_x, '... -&gt; 1 1 1 ...')\n    sigma_y = einops.rearrange(self.sigma_y, '... -&gt; 1 1 1 ...')\n    sigma_z = einops.rearrange(self.sigma_z, '... -&gt; 1 1 1 ...')\n\n\n    gaussian = amplitude * torch.exp(\n        -((grid_x - center_x) ** 2 / (2 * sigma_x ** 2) +\n          (grid_y - center_y) ** 2 / (2 * sigma_y ** 2) +\n          (grid_z - center_z) ** 2 / (2 * sigma_z ** 2))\n    )\n\n    return einops.rearrange(gaussian, 'd h w ... -&gt; ... d h w')\n</code></pre>"},{"location":"#torch_find_peaks.gaussians.WarpedGaussian2D","title":"<code>WarpedGaussian2D</code>","text":"<p>               Bases: <code>Module</code></p> <p>A 2D warped Gaussian function.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>tensor</code> <p>Amplitude of the Gaussian. Default is torch.tensor([1.0]).</p> <code>tensor([1.0])</code> <code>center_x</code> <code>tensor</code> <p>X-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>tensor([0.0])</code> <code>center_y</code> <code>tensor</code> <p>Y-coordinate of the center. Default is torch.tensor([0.0]).</p> <code>tensor([0.0])</code> <code>sigma_x</code> <code>tensor</code> <p>Standard deviation along the x-axis. Default is torch.tensor([1.0]).</p> <code>tensor([1.0])</code> <code>sigma_y</code> <code>tensor</code> <p>Standard deviation along the y-axis. Default is torch.tensor([1.0]).</p> <code>tensor([1.0])</code> <code>warp</code> <code>tensor</code> <p>Warp factor for the Gaussian. Default is torch.tensor([1.0]).</p> <code>tensor([1.0])</code> <code>warp_angle</code> <code>tensor</code> <p>Angle of the warp in radians. Default is torch.tensor([0.0]).</p> <code>tensor([0.0])</code> <p>Methods:</p> Name Description <code>forward</code> <p>Compute the warped Gaussian values for a given 2D grid.</p> Source code in <code>src/torch_find_peaks/gaussians.py</code> <pre><code>class WarpedGaussian2D(nn.Module):\n    \"\"\"\n    A 2D warped Gaussian function.\n\n    Parameters\n    ----------\n    amplitude : torch.tensor, optional\n        Amplitude of the Gaussian. Default is torch.tensor([1.0]).\n    center_x : torch.tensor, optional\n        X-coordinate of the center. Default is torch.tensor([0.0]).\n    center_y : torch.tensor, optional\n        Y-coordinate of the center. Default is torch.tensor([0.0]).\n    sigma_x : torch.tensor, optional\n        Standard deviation along the x-axis. Default is torch.tensor([1.0]).\n    sigma_y : torch.tensor, optional\n        Standard deviation along the y-axis. Default is torch.tensor([1.0]).\n    warp : torch.tensor, optional\n        Warp factor for the Gaussian. Default is torch.tensor([1.0]).\n    warp_angle : torch.tensor, optional\n        Angle of the warp in radians. Default is torch.tensor([0.0]).\n\n    Methods\n    -------\n    forward(grid)\n        Compute the warped Gaussian values for a given 2D grid.\n    \"\"\"\n\n    def __init__(self,\n                 amplitude: torch.tensor = torch.tensor([1.0]),\n                 center_x: torch.tensor = torch.tensor([0.0]),\n                 center_y: torch.tensor = torch.tensor([0.0]),\n                 sigma_x: torch.tensor = torch.tensor([1.0]),\n                 sigma_y: torch.tensor = torch.tensor([1.0]),\n                 warp: torch.tensor = torch.tensor([1.0]),\n                 warp_angle: torch.tensor = torch.tensor([0.0])\n    ):\n        super(WarpedGaussian2D, self).__init__()\n        # Ensure that the parameters are tensors\n        if not isinstance(amplitude, torch.Tensor):\n            amplitude = torch.tensor(amplitude)\n        if not isinstance(center_x, torch.Tensor):\n            center_x = torch.tensor(center_x)\n        if not isinstance(center_y, torch.Tensor):\n            center_y = torch.tensor(center_y)\n        if not isinstance(sigma_x, torch.Tensor):\n            sigma_x = torch.tensor(sigma_x)\n        if not isinstance(sigma_y, torch.Tensor):\n            sigma_y = torch.tensor(sigma_y)\n        if not isinstance(warp, torch.Tensor):\n            warp = torch.tensor(warp)\n        if not isinstance(warp_angle, torch.Tensor):\n            warp_angle = torch.tensor(warp_angle)\n        # Check if all parameters are of the same shape\n        assert amplitude.shape == center_x.shape == center_y.shape == sigma_x.shape == sigma_y.shape == warp.shape == warp_angle.shape, \\\n            \"All parameters must have the same shape.\"\n\n        self.amplitude = nn.Parameter(amplitude)\n        self.center_x = nn.Parameter(center_x)\n        self.center_y = nn.Parameter(center_y)\n        self.sigma_x = nn.Parameter(sigma_x)\n        self.sigma_y = nn.Parameter(sigma_y)\n        self.warp = nn.Parameter(warp)\n        self.warp_angle = nn.Parameter(warp_angle)\n\n    def forward(self, grid):\n        \"\"\"\n        Forward pass for 2D warped Gaussian list.\n\n        Args:\n            grid: Tensor of shape (h,w, 2) containing 2D coordinates.\n\n        Returns\n        -------\n            Tensor of warped Gaussian values\n        \"\"\"\n        amplitude = einops.rearrange(self.amplitude, '... -&gt; 1 1 ...')\n        center_x = einops.rearrange(self.center_x, '... -&gt; 1 1 ...')\n        center_y = einops.rearrange(self.center_y, '... -&gt; 1 1 ...')\n        sigma_x = einops.rearrange(self.sigma_x, '... -&gt; 1 1 ...')\n        sigma_y = einops.rearrange(self.sigma_y, '... -&gt; 1 1 ...')\n        warp = einops.rearrange(self.warp, '... -&gt; 1 1 ...')\n        warp_angle = einops.rearrange(self.warp_angle, '... -&gt; 1 1 ...')\n\n        grid_x = einops.rearrange(grid[..., 1], 'h w -&gt; h w 1')\n        grid_y = einops.rearrange(grid[..., 0], 'h w -&gt; h w 1')\n\n        u = (grid_x - center_x) * torch.cos(warp_angle) - (grid_y - center_y) * torch.sin(warp_angle)\n        v = (grid_x - center_x) * torch.sin(warp_angle) + (grid_y - center_y) * torch.cos(warp_angle)\n\n        warped_gaussian = amplitude * torch.exp(\n            -((u - warp * v ** 2) ** 2 / (2 * sigma_x ** 2) +\n              v ** 2 / (2 * sigma_y ** 2))\n        )\n\n        return einops.rearrange(warped_gaussian, 'h w ... -&gt; ... h w')\n</code></pre>"},{"location":"#torch_find_peaks.gaussians.WarpedGaussian2D.forward","title":"<code>forward(grid)</code>","text":"<p>Forward pass for 2D warped Gaussian list.</p> <p>Args:     grid: Tensor of shape (h,w, 2) containing 2D coordinates.</p> <p>Returns:</p> Type Description <code>    Tensor of warped Gaussian values</code> Source code in <code>src/torch_find_peaks/gaussians.py</code> <pre><code>def forward(self, grid):\n    \"\"\"\n    Forward pass for 2D warped Gaussian list.\n\n    Args:\n        grid: Tensor of shape (h,w, 2) containing 2D coordinates.\n\n    Returns\n    -------\n        Tensor of warped Gaussian values\n    \"\"\"\n    amplitude = einops.rearrange(self.amplitude, '... -&gt; 1 1 ...')\n    center_x = einops.rearrange(self.center_x, '... -&gt; 1 1 ...')\n    center_y = einops.rearrange(self.center_y, '... -&gt; 1 1 ...')\n    sigma_x = einops.rearrange(self.sigma_x, '... -&gt; 1 1 ...')\n    sigma_y = einops.rearrange(self.sigma_y, '... -&gt; 1 1 ...')\n    warp = einops.rearrange(self.warp, '... -&gt; 1 1 ...')\n    warp_angle = einops.rearrange(self.warp_angle, '... -&gt; 1 1 ...')\n\n    grid_x = einops.rearrange(grid[..., 1], 'h w -&gt; h w 1')\n    grid_y = einops.rearrange(grid[..., 0], 'h w -&gt; h w 1')\n\n    u = (grid_x - center_x) * torch.cos(warp_angle) - (grid_y - center_y) * torch.sin(warp_angle)\n    v = (grid_x - center_x) * torch.sin(warp_angle) + (grid_y - center_y) * torch.cos(warp_angle)\n\n    warped_gaussian = amplitude * torch.exp(\n        -((u - warp * v ** 2) ** 2 / (2 * sigma_x ** 2) +\n          v ** 2 / (2 * sigma_y ** 2))\n    )\n\n    return einops.rearrange(warped_gaussian, 'h w ... -&gt; ... h w')\n</code></pre>"},{"location":"examples/find_golds/","title":"Find golds","text":"In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\nimport mrcfile\nimport pooch\nimport torch\nfrom torch_peaks.find_peaks import peak_local_max_3d\n</pre> import matplotlib.pyplot as plt import mrcfile import pooch import torch from torch_peaks.find_peaks import peak_local_max_3d In\u00a0[3]: Copied! <pre>tomo = pooch.retrieve(\"https://ftp.ebi.ac.uk/pub/databases/emdb/structures/EMD-25061/map/emd_25061.map.gz\",known_hash=None)\n</pre>  tomo = pooch.retrieve(\"https://ftp.ebi.ac.uk/pub/databases/emdb/structures/EMD-25061/map/emd_25061.map.gz\",known_hash=None)  In\u00a0[4]: Copied! <pre>with mrcfile.open(tomo, mode='r') as mrc:\n    # print the map header\n    tomo_data = torch.tensor(mrc.data).to(\"cuda:0\")\n</pre> with mrcfile.open(tomo, mode='r') as mrc:     # print the map header     tomo_data = torch.tensor(mrc.data).to(\"cuda:0\")  In\u00a0[5]: Copied! <pre>with torch.no_grad():\n    # Find peaks in the 3D volume\n    peaks = peak_local_max_3d(\n                volume = -1. * tomo_data,\n                threshold_abs=30,\n                min_distance=3,\n            )\n</pre> with torch.no_grad():     # Find peaks in the 3D volume     peaks = peak_local_max_3d(                 volume = -1. * tomo_data,                 threshold_abs=30,                 min_distance=3,             ) In\u00a0[11]: Copied! <pre>fig, [pl1, pl2] = plt.subplots(1, 2, figsize=(6, 4))\ntomo_data = tomo_data.cpu()\npl1.imshow(torch.min(tomo_data, dim=0).values, cmap='gray',interpolation='mitchell', vmin=0, vmax=70)\npeaks = peaks.cpu()\npl2.imshow(torch.min(tomo_data, dim=0).values, cmap='gray',interpolation='mitchell', vmin=0, vmax=70)\npl2.plot(peaks[:, 2], peaks[:, 1], 'r.', markersize=2)\nplt.tight_layout()\nplt.show()\n</pre> fig, [pl1, pl2] = plt.subplots(1, 2, figsize=(6, 4)) tomo_data = tomo_data.cpu() pl1.imshow(torch.min(tomo_data, dim=0).values, cmap='gray',interpolation='mitchell', vmin=0, vmax=70) peaks = peaks.cpu() pl2.imshow(torch.min(tomo_data, dim=0).values, cmap='gray',interpolation='mitchell', vmin=0, vmax=70) pl2.plot(peaks[:, 2], peaks[:, 1], 'r.', markersize=2) plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/plot_gaussians/","title":"Plot gaussians","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport torch\nfrom torch_grid_utils.coordinate_grid import coordinate_grid\n\nfrom torch_find_peaks.gaussians import Gaussian2D, WarpedGaussian2D\n\ng1 = Gaussian2D(1.,0., 0., 10., 5.)\n\ngrid = coordinate_grid((100,100), center=torch.tensor([50.,50.]))\n\nim_g1 = g1(grid)\n</pre> import matplotlib.pyplot as plt import torch from torch_grid_utils.coordinate_grid import coordinate_grid  from torch_find_peaks.gaussians import Gaussian2D, WarpedGaussian2D  g1 = Gaussian2D(1.,0., 0., 10., 5.)  grid = coordinate_grid((100,100), center=torch.tensor([50.,50.]))  im_g1 = g1(grid) In\u00a0[2]: Copied! <pre>plt.imshow(im_g1.detach().numpy(), cmap='gray')\n</pre> plt.imshow(im_g1.detach().numpy(), cmap='gray') Out[2]: <pre>&lt;matplotlib.image.AxesImage at 0x7f080132da60&gt;</pre> In\u00a0[6]: Copied! <pre>g2 = WarpedGaussian2D(1.,0.,0., 5.0, 5.0, 0.2, 0.)\n</pre> g2 = WarpedGaussian2D(1.,0.,0., 5.0, 5.0, 0.2, 0.) In\u00a0[7]: Copied! <pre>im_g2 = g2(grid)[0]\nplt.imshow(im_g2.detach().numpy(), cmap='gray')\n</pre> im_g2 = g2(grid)[0] plt.imshow(im_g2.detach().numpy(), cmap='gray') Out[7]: <pre>&lt;matplotlib.image.AxesImage at 0x7f2e51be4a10&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}